---
발표자: [장진아]
발표일: [2024-01-28]
---

# 장진아 - 9장 1부

# 9장. 일관성과 합의

- 분산 시스템에서 *결함을 견뎌낼(tolerating)*, 즉 내부 구성 요소에 *결함이 있더라도 서비스는 올바르게 동작하게 할 방법*을 찾아야 한다
- 내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 *유용한 보장을 해주는(애플리케이션이 분산 시스템에 있는 문제를 무시할 수 있게 만들어주는) 범용 추상화를 찾아 이를 구현하고 애플리케이션에서 이 보장에 의존*하게 하는 것이다
    - 분산 시스템에서 가장 중요한 추상화는 **합의**, 즉 모든 노드가 어떤 것에 동의하게 만드는 것
- 이번 장에서 *분산 시스템에서 제공될 수 있는 보장과 추상화의 범위*를 알아보고, *합의와 합의 관련 문제를 해결하는 알고리즘*을 살펴본다

## 일관성 보장

- 복제 데이터베이스는 대부분 최소한 **최종적 일관성**을 제공한다
    - 데이터베이스에 쓰기를 멈추고 불특정 시간 동안 기다리면 결국 모든 읽기 요청이 같은 값을 반환
        - 불일치는 일시적이며 결국 스스로 해소한다
- 그러나 이것은 매우 약한 보장
    - 언제 복제본이 (같은 값으로 )수렴될지에 대해서는 알 수 없다
- 이번 장에서 데이터 시스템이 선택적으로 제공할 수 있는 더욱 강한 일관성 모델을 살펴본다
    - 강한 보장을 제공하는 시스템은 성능이 나쁘거나 약한 보장을 제공하는 시스템보다 내결함성이 약할지도 모른다
    - 그럼에도 강한 보장은 올바르게 사용하기 쉬우므로 매력적
- 분산 일관성 모델과 트랜잭션 격리 수준 계층에는 비슷한 점이 있다
    - 이들은 대개 독립적인 관심사
        - 트랜잭션 격리는 주로 동시에 실행되는 트랜잭션 때문에 발생하는 경쟁 조건을 회피하기 위한 것
        - 분산 일관성은 지연과 결함이 있더라도 복제본의 상태를 코디네이션하는 것에 관한 것
    - 그러나 사실 이 영역들은 깊게 연결돼 있다
        - 공통적으로 사용되는 가장 강한 일관성 모델 중 하나인 선형성(linearizability)
        - 분산 시스템에서의 이벤트 순서화 문제, 특히 인과성과 전체 순서화와 관련된 문제
        - 분산 트랜잭션을 원자적으로 커밋하는 방법

## 선형성

- 선형성의 기본 아이디어
    - 시스템에 데이터 복사본이 하나만 있고 그 데이터를 대상으로 수행하는 모든 연산은 원자적인 것처럼 보이게 만드는 것
    - 이런 보장이 있다면 현실에는 여러 복제본이 있더라도 애플리케이션이 거기에 신경 쓸 필요가 없다
- 선형성은 **최신성 보장(recency guarantee)**
    - 읽힌 값이 최근에 갱신된 값이며 뒤처진 캐시나 복제본에서 나온 값이 아니라고 보장해준다

![](/img/part2/9.1.jpeg)

- 선형성 위반 사례
    - 밥은 앨리스가 최종 점수를 외친 것을 들은 후에 새로고침 버튼을 눌렀음(질의를 실행했음)을 알고 따라서 그는 질의의 결과가 적어도 앨리스의 질의 결과만큼은 새로워야 한다고 기대한다

### 시스템에 선형성을 부여하는 것은 무엇인가?

![](/img/part2/9.2.jpeg)

- 쓰기는 쓰기 연산의 시작과 끝 사이의 어느 시점에선가 처리되어야 하고 읽기는 읽기 연산의 시작과 끝 사이의 어느 시점에선가 처리되어야 한다
- 쓰기 연산과 시간이 겹치는 읽기 연산은 0을 반환할 수도 1을 반환할 수도 있다
    - 쓰기와 동시에 실행되는 읽기가 오래된 값과 새로운 값 사이에서 여러 번 왔다 갔다 하는 것은 “데이터의 단일 복사본”을 모방하는 시스템에 기대하는 바가 아니다

![](/img/part2/9.3.jpeg)

- 새로운 제약 조건을 추가해 한 클라이언트가 새로운 값 1을 반환하면 이후의 모든 읽기 또한 새로운 값을 반환해야 한다(쓰기 연산이 아직 완료되지 않았더라도)
    - A의 읽기가 반환된 후 B의 읽기는 확실히 A의 읽기 뒤에 실행되므로 C가 실행한 쓰기가 아직 진행 중이라도 역시 1을 반환해야 한다

![](/img/part2/9.4.jpeg)

- 선형성의 요구사항은 연산 표시를 모은 선들이 항상 시간순으로 진행돼야 하고 결코 뒤로 가서는 안된다는 것이다
- 데이터베이스가 D의 쓰기를 먼저 처리한 후 A의 쓰기를 처리하고 마지막으로 B의 읽기를 처리했다
    - 요청을 보낸 순서와는 다르지만 세 요청이 동시적이기 때문에 이 순서는 허용된다
- 클라이언트 B의 읽기는 클라이언트 A가 데이터베이스로부터 값을 1로 쓰는 데 성공했다는 응답을 받기 전에 1을 반환했다
    - 값이 쓰여지기 전에 읽혔다는 의미가 아니라 데이터베이스에서 클라이언트 A로 가는 ok 응답이 네트워크에서 지연됐다는 의미
- 이 모델은 어떤 트랜잭션 격리도 가정하지 않는다
    - 다른 클라이언트가 동시에 값을 바꾸지 않았는지 확인하기 위해 원자적 compare-and-set(cas) 연산을 사용할 수 있다
- 클라이언트 B의 마지막 읽기는 선형적이지 않다
    - 이 연산은 C의 cas 쓰기와 동시적이다
    - 클라이언트 A는 B의 읽기가 시작하기 전에 이미 새로운 값 4을 읽었다
    - 따라서 B는 A가 읽은 것보다 과거의 값을 읽는 것이 허용되지 않는다
- 선형성과 직렬성
    - 직렬성
        - 모든 트랜잭션이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션의 격리 속성
        - 트랜잭션들이 *어떤 순서에 따라* 실행되는 것처럼 동작하도록 보장해준다
        - 그 순서가 트랜잭션들이 실제 실행되는 순서와 달라도 상관 없다
    - 선형성
        - 레지스터(개별 객체)에 실행되는 읽기와 쓰기에 대한 최신성 보장
        - 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 부가적인 수단을 사용하지 않으면 쓰기 스큐같은 문제를 막지 못한다
    - 데이터베이스는 직렬성과 선형성을 모두 제공할 수 있으며, 이런 조합을 엄격한 *직렬성(strict serializability)* 또는 *강한 단일 복사본 직렬성(strong one-copy serializability, strong-1SR)*이라고 한다
        - 2단계 잠금(2PL)이나 실제적인 직렬 실행을 기반으로 한 직렬성 구현은 보통 선형적
        - 직렬성 스냅숏 격리(SSI)는 선형적이지 않다
            - 직렬성 스냅숏 격리는 설계상 읽는 쪽과 쓰는 쪽 사이의 잠금 경쟁을 피하기 위해 일관된 스냅숏에서 읽는다
            - 일관된 스냅숏의 요점은 스냅숏보다 나중에 실행된 쓰기를 포함하지 않는다는 것이고, 따라서 스냅숏에서 읽으면 선형적이지 않다

### 선형성에 기대기

- 어떤 환경에서 선형성이 유용할까?
    - **잠금과 리더 선출**
        - 단일 리더 복제 시스템은 리더가 진짜로 하나만 존재하도록 보장해야 한다
        - 리더를 선출하는 방법은 잠금을 사용하는 것이고, 이 잠금은 어떻게 구현하든지 선형적이어야 한다
        - 분산 잠금과 리더 선출을 구현하기 위해 아파치 주키퍼나 etcd 같은 코디네이션 서비스가 사용
            - 합의 알고리즘을 사용해 선형성 연산을 내결함성이 있는 방식으로 구현
            - 아파치 큐레이터 같은 라이브러리가 주키퍼 위에 고수준 레시피를 제공해서 도움을 준다
        - 분산 잠금은 오라클 리얼 애플리케이션 클러스터(RAC) 같은 분산 데이터베이스에서 훨씬 세분화된 수준으로 사용되기도 한다
            - RAC는 여러 노드가 동일한 디스크 저장 시스템을 공유해서 접근 → 디스크 페이지마다 잠금을 사용
    - **제약 조건과 유일성 보장**
        - 사용자명이나 이메일 주소는 사용자 한 명을 유일하게 식별할 수 있어야 하며 파일 저장 서비스에서는 경로와 파일 이름이 동일한 파일이 두 개 있을 수 없다
            - 잠금과 비슷 → 사용자가 선택한 사용자명에 “잠금”을 획득하는 것으로 생각
            - 연산은 원자적 compare-and-set과도 매우 비슷
        - 은행 계좌 잔고가 결코 음수가 되지 않게 하거나 창고에 있는 재고보다 더 팔지 않게 하거나 두 사람이 동시에 같은 비행기나 영화 좌석을 예매하지 못하게 보장하고 싶을 때 → 모드 노드가 동의하는 하나의 최신 값이 있기를 요구한다
    - **채널 간 타이밍 의존성**

      ![](/img/part2/9.5.jpeg)

        - 사용자가 사진을 올리고 백그라운드 프로세스가 사진을 빨리 내려받을 수 있도록 저해상도로 바꾸는(썸네일) 웹사이트
            - 파일 저장 서비스가 선형적이지 않다면 경쟁 조건의 위험이 있다
            - 메시지 큐가 저장 서비스 내부의 복제보다 빠를 수도 있다
            - 이런 경우 크기 변경 모듈이 이미지를 읽으면 그 이미지의 과거 버전을 보거나 아무것도 보지 못할 수도 있다
        - 웹 서버와 크기 변경 모듈 사이에 두 가지 다른 통신 채널, 파일 저장소와 메시지 큐가 있기 때문에 발생한다
            - 선형성의 최신성 보장이 없으면 두 채널 사이에 경쟁 조건이 발생할 수 있다

### 선형성 시스템 구현하기

- 복제를 통해 시스템이 내결함성을 지니도록 하면서 이를 선형적으로 만들 수 있는가?
    - 단일 리더 복제(선형적이 될 가능성 있음)
        - 리더나 동기식으로 갱신된 팔로워에서 실행한 읽기는 선형적이 될 가능성이 있다
        - 리더가 아닌 노드가 자신이 리더라고 생각해서 계속해서 요청을 처리하면 선형성을 위반하기 쉽다
        - 비동기 복제를 사용하면 장애 복구를 할 때 커밋된 쓰기가 손실될 수 있는데, 이는 지속성과 선형성을 모두 위반하는 것
    - 합의 알고리즘(선형적)
        - 단일 리더 복제를 닮았지만, 스플릿 브레인과 복제본이 뒤처지는 문제를 막을 수단이 포함된다
        - 주키퍼와 etcd가 이렇게 동작한다
    - 다중 리더 복제(비선형적)
        - 여러 노드에서 동시에 쓰기를 처리하고 그 내용을 비동기로 다른 노드에 복제하므로 일반적으로 비선형적이다
        - 다중 리더 복제 시스템은 충돌 해소가 필요한 충돌 쓰기를 만들 수 있다
    - 리더 없는 복제(아마도 비선형적)
        - 정족수 읽기와 쓰기를 요구함으로써 “엄격한 일관성”을 달성할 수 있다고 주장하지만 완전한 진실은 아니다
        - 일 기준 시계를 기반으로 한 “최종 쓰기 승리” 충돌 해소 방법은 거의 확실히 비선형적이다
        - 시계 타임스탬프는 시계 스큐 때문에 이벤트의 실제 순서와의 일치를 보장할 수 없다
        - 느슨한 정족수도 선형성의 가능성을 망친다

### 선형성과 정족수

![](/img/part2/9.6.jpeg)

- 정족수 조건이 만족(w + r > n)됨에도 이 실행은 선형적이지 않다
    - 클라이언트 B는 두 노드로 구성된 다른 정족수로부터 읽어서 두 노드 모두에서 예전 값 0을 본다
- 성능이 떨어지는 비용을 지불하고 다이나모 스타일 정족수를 선형적으로 만드는 게 가능하다
    - 읽기를 실행하는 클라이언트는 결과를 반환하기 전에 읽기 복구를 동기식으로 수행
    - 쓰기를 실행하는 클라이언트는 쓰기 요청을 보내기 전에 노드들의 정족수로부터 최신 상태 읽기를 수행
    - 그러나 리악은 성능상 불이익 때문에 동기식 읽기 복구를 수행 X
    - 카산드라는 정족수 읽기를 할 때 읽기 복구가 완료되기를 기다리지만 최종 쓰기 승리 충돌 해소 방법을 쓰기 때문에 같은 키에 여러 쓰기를 동시에 실행하면 선형성을 잃게 된다
- 다이나모 스타일 복제를 하는 리더 없는 시스템은 선형성을 제공하지 않는다고 보는 게 가장 안전하다

### 선형성의 비용

![](/img/part2/9.7.jpeg)

- 각 데이터센터의 내부 네트워크는 동작하고 클라이언트는 데이터센터에 접근할 수 있지만 데이터센터끼리는 서로 연결할 수 없다고 가정한 사례
    - 다중 리더 데이터베이스에서 각 데이터센터는 계속 정상 동작할 수 있다
        - 한 데이터센터에 쓰여진 내용이 비동기로 다른 데이터센터로 복제되므로 쓰기는 그냥 큐에 쌓였다가 네트워크 연결이 복구되면 전달된다
    - 단일 리더 설정에서 데이터센터 사이의 네트워크가 끊기면 팔로워 데이터센터로 접속한 클라이언트들은 리더로 연결할 수 없으므로 아무것도 쓸 수 없고 선형적 읽기도 할 수 없다
        - 팔로워로부터 읽을 수는 있지만 비선형적(뒤처졌을 수 있다)
        - 애플리케이션에서 선형성 읽기와 쓰기를 요구한다면 네트워크가 끊길 때 리더와 연결할 수 없는 데이터센터에서는 애플리케이션을 사용할 수 없다
        - 클라이언트가 리더 데이터센터로 직접 접속할 수 없다면 해당 클라이언트는 네트워크 링크가 복구될 때까지 중단을 경험한다

### CAP 정리

- 애플리케이션에서 *선형성을 요구하고* 네트워크 문제 때문에 일부 복제 서버가 다른 복제 서버와 연결이 끊기면 일부 복제 서버는 요청을 처리할 수 없다(*가용성 X*)
- 애플리케이션에서 선형성을 요구하지 않는다면 이 애플리케이션은 네트워크 문제에 직면해도 가용한 상태를 유지하지만 그 동작은 선형적이지 않다
- CAP 정리
    - CAP는 각각 **일관성(Consistency)**, **가용성(Availability)**, **분단 내성(Partition tolerance)**를 의미하며, 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 선택하라는 의미로 이해하는 게 좋다
    - 선형성이 필요 없는 애플리케이션은 네트워크 문제에 더 강인하다
- 공식적으로 정의된 CAP 정리는 매우 범위가 좁고 네트워크 지연, 죽은 노드나 다른 트레이드오프에 대한 어떤 것도 고려하지 않기 때문에 역사적인 영향력은 있지만 시스템을 설계할 때는 실용적인 가치가 거의 없다

### 선형성과 네트워크 지연

- 선형성은 유용한 보장이지만 현실에서 실제로 선형적인 시스템은 놀랄 만큼 드물다, 왜?
    - 선형성은 느리다
    - 여러 분산 데이터베이스는 성능을 향상시키기 위해서 선형성 보장을 제공하기 않기를 택한다
    - 심지어 최신 다중코어 CPU의 램(RAM)조차 선형적이지 않다
        - 모든 CPU 코어가 저마다 메모리 캐시와 저장 버퍼를 갖기 때문
        - 메모리 접근은 기본적으로 캐시로 먼저 가고(훨씬 빠르니까) 변경은 메인 메모리에 비동기로 기록
        - 이런 특성은 성능에 필수적, 그러나 데이터 복사본이 여러 개 생기고 비동기로 갱신되므로 선형성은 손실

## 순서화 보장

- 선형성 레지스터는 연산들이 어떤 잘 *정의된 순서대로 실행된다*는 것을 암시한다
- 순서화는 계속해서 되풀이되는 주제이며, 중요한 근본적 아이디어일 수 있다는 것을 시사한다
    - 단일 리더 복제에서 리더의 주 목적은 복제 로그에서 쓰기의 순서, 즉 팔로워가 쓰기를 적용하는 순서를 결정한다
    - 직렬성은 트랜잭션들이 마치 어떤 일련의 순서에 따라 실행되는 것처럼 동작하도록 보장하는 것과 관련돼 있다
    - 분산 시스템에서 타임스탬프와 시계 사용은 무질서한 세상에 질서(순서)를 부여하려는 시도다.
- 순서화, 선형성, 합의 사이에는 깊은 연결 관계가 있음이 드러난다

### 순서화와 인과성

- 순서화는 인과성을 보존하는 데 도움을 준다
    - 일관된 순서로 읽기에서 질문에 대한 응답을 먼저 보고 나서 응답된 질문을 보게 되면 원인과 결과에 관한 직관을 위반하기 때문에 혼란스럽다
        - 질문과 답변 사이에 인과적 의존성이 있다
    - 리더 사이의 복제에서 네트워크 지연 때문에 어떤 쓰기가 다른 쓰기를 “추월”할 수 있음을 알았다
        - 인과성은 로우가 갱신되기 전에 먼저 생성돼야 함을 의미한다
    - 이전 발생(happened before) 관계는 인과성을 표현하는 또 다른 방법이다
        - A가 B보다 먼저 실행됐다면 B가 A에 대해 알거나 A를 기반으로 하거나 A에 의존할지도 모른다
        - A와 B가 동시적이면 그들 사이에는 인과적 연결이 없다
    - 트랜잭션용 스냅숏 격리의 맥락에서 트랜잭션은 일관된 스냅숏으로부터 읽는다
        - 이 맥락에서 “일관적”이란 인과성에 일관적(consistent with causality)이라는 의미다
        - 한 시점에서 데이터베이스를 보면 인과성 측면에서 그 시점 전에 실행된 모든 연산의 효과는 볼 수 있지만 나중에 실행된 연산의 효과는 볼 수 없다
    - 트랜잭션들 사이의 쓰기 스큐 예제는 인과적 의존성을 보여준다
        - 호출 대기에서 빠지는 동작은 현재 누가 호출 대기 중인지 관찰하는 것에 인과적으로 의존한다
        - 직렬성 스냅숏 격리는 트랜잭션 사이의 인과적 의존성을 추적함으로써 쓰기 스큐를 검출한다
    - 앨리스의 탄성은 점수 발표에 인과적으로 의존적이므로 밥 또한 앨리스의 외침을 들은 후에 그 점수를 볼 수 있어야 한다
- 인과성은 이벤트에 순서를 부과한다
    - 결과가 나타나기 전에 원인이 발생한다
- 인과적으로 의존하는 연산의 연쇄는 시스템에서 인과적 순서, 즉 무엇이 무엇보다 먼저 일어났는가를 정의한다
- 시스템이 인과성에 의해 부과된  순서를 지키면 그 시스템은 *인과적으로 일관적(causally consistent)*이라고 한다

### 인과적 순서가 전체 순서는 아니다

- 전체 순서(total order)는 어떤 두 요소를 비교할 수 있게 하므로 두 요소가 있으면 항상 어떤 것이 더 크고 어떤 것이 더 작은지 말할 수 있다
- 수학적 집합은 항상 전체 순서를 정할 수 있는 것이 아니다
    - 어느 것도 다른 것의 부분 집합이 아니므로 이것들은 비교 불가(incomparable)
    - 수학적 집합은 부분적으로 순서가 정해진다(partially ordered)
        - 어떤 경우에는 한 집합이 다른 집합보다 크지만 다른 경우에는 비교 불가능하다
- 선형성
    - 연산의 전체 순서를 정할 수 있다
    - 어떤 두 연산에 대해 항상 둘 중 하나가 먼저 실행됐다고 말할 수 있다
- 인과성
    - 두 이벤트에 인과적인 관계가 있으면 이들은 순서가 있지만 이들이 동시에 실행됐다면 비교할 수 없다
    - 인과성이 전체 순서가 아닌 부분 순서를 정의한다는 뜻이다
- 정의에 따르면 선형적 데이터스토어에는 동시적 연산이 없다
    - 하나의 타임라인이 있고, 모든 연산은 그 타임라인을 따라서 전체 순서가 정해져야 한다
- 동시성은 타임라인이 갈라졌다 다시 합쳐지는 것을 의미한다
    - 깃의 버전 히스토리는 인과적 의존성 그래프와 매우 유사하다

### 선형성은 인과적 일관성보다 강하다

- 선형성은 인과성을 **내포한다**
    - 어떤 시스템이든지 선형적이라면 인과성도 올바르게 유지한다
- 그러나 시스템을 선형적으로 만들면, 특히 네트워크 지연이 크면 성능과 가용성에 해가 될 수 있다
- 시스템은 선형적으로 만드는 성능 손해를 유발하지 않고도 인과적 일관성을 만족시킬 수 있다
    - 인과적 일관성은 네트워크 지연 때문에 느려지지 않고 네트워크 장애가 발생해도 가용한 일관성 모델 중 가장 강한 것이다
- 많은 경우에 선형성이 필요한 것처럼 보이는 시스템에 사실 진짜로 필요한 것은 인과적 일관성이며 이는 더 효율적으로 구현될 수 있다

### 인과적 의존성 담기

- 인과성을 유지하기 위해 어떤 연산이 다른 연산보다 **먼저 실행됐는지** 알아야 한다
    - 부분 순서 → 동시에 실행되는 연산은 어떤 순서로든 처리될 수 있지만 한 연산이 다른 연산보다 먼저 실행됐다면 모든 복제 서버에서 그 순서로 처리돼야 한다
- 어떤 연산이 다른 연산보다 먼저 실행됐는지 결정하는 기법
    - 단일 키뿐만 아니라 전체 데이터베이스에 걸친 인과적 의존성을 추적해야 한다
    - 이를 위해 버전 벡터(version vector)를 일반화할 수 있다
    - 인과적 순서를 결정하기 위해 데이터베이스는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야 한다