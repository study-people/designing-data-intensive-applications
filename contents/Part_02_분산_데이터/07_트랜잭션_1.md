---
발표자: 김건
발표일: 2024-01-07
---

# 7장 트랜잭션

- 데이터베이스 SW or HW는 언제든지 실패할 수 있다.
- 애플리케이션은 언제라도 죽을 수 있다.
- 네트워크가 끊기면 애플리케이션과 데이터베이스의 연결이 갑자기 끊기거나 통신이 안될 수 있다.
- 여러 클라이언트가 동시에 데이터베이스에 쓰기를 실행해서 다른 클라이언트가 쓴 내용을 덮어쓸 수 있다.(LWW)
- 클라이언트가 부분적으로만 갱신돼서 비정상적인 데이터를 읽을 수 있다.
- 클라이언트 사이 경쟁 조건은 예측하지 못한 버그를 유발할 수 있다.

트랜잭션은 이런 문제를 단순화하기 위해 전체가 성공(커밋), 실패(롤백)한다.

동시성 제어 분야에서는 여러 경쟁 조건

- 커밋 후 읽기(read committed)
- 스냅숏 격리(snapshot isolation)
- 직렬성(serializability)

가 존재한다.

## 애매모호한 트랜잭션 개념

데이터베이스마다 구현하는 트랜잭션의 강도가 다르기  때문에 트랜잭션 개념이 조금 애매모호하다. 어디서는 느슨한 트랜잭션, 어디서는 강도 높은 트랜잭션을 구현한다.

### ACID 의미

- 원자성(Atomicity)
- 일관성(Consistency)
- 격리성(Isolation)
- 지속성(Durability)

ACID 구현은 제각각이며 격리성에 모호함이 있다.

### 원자성

원자적이란 쪼갤 수 없는 것을 의미하지만, 대충 어보트 능력(abortability) 정도.

### 일관성

= 좋은 상태

### 격리성

한 트랜잭션의 작업은 다른 트랜잭션에 의해 영향을 받으면 안된다.

직렬성 격리 같은 경우엔  성능 오버헤드로 인해 거의 사용되지 않음

- 한번에 하나의 스레드만 작업할 수 있기 때문에 동시성을 해치게 된다.

팬텀 리드, 더티 리드 등 다른 트랜잭션에 의해 영향을 받을 수 있음.

혹은 동시 접근으로 인해 동시성 문제가 발생할 수도 있음.

### 지속성

한번 쓴 데이터는 비휘발성 저장소에 기록되어 잃어버리지 않아야 한다.

### 단일 객체 연산과 다중 객체 연산

- 원자성
- 격리성: 서로 방해하지 말아야 하고, 다른 트랜잭션은 그 내용을 모두 보던지 안 보던지 둘 중 하나만 해야 한다. 즉 일부분만 보이거나 하는 등 X

원자성, 격리성 두개에 대해 나오는 듯?

### 단일 객체 쓰기

원자성과 격리성은 단일 객체를 변경하는 경우에도 적용된다.

- 일부분 데이터만 전달 받은 상태에서 네트워크 연결이 끊긴 경우, 이 데이터를 저장할 것인지?
- 데이터베이스가 디스크에 새 데이터를 덮어쓰는 도중에 전원이 나갈 경우 기존 값과 새 값은 공존하게 될까?
- 문서를 쓰고 있을 때 다른 클라이언트가 그 문서를 읽으면 부분 갱신된 값을 읽게 될까?

이 문제들은 혼란스럽기 때문에 저장소 엔진들은 거의 보편적으로 한 노드에 존재하는 단일 객체 수준에서 원자성/격리성 제공을 목표로 한다.

원자성은 장애 복구 로그를 통해 구현할 수 있고, 격리성은 각 개체 잠금을 사용해 구현할 수 있다.

어떤 데이터베이스는 compare-and-set 연산을 제공해 read-modify-write 주기 반복을 없앤다.

- 즉, 데이터를 쓰기 전에 해당 데이터가 누군가에 의해 변경됐는지를 체크하고, 변경되지 않았을 경우에만 쓰기를 허용한다.
- 이 기능은 갱신 손실(lost update)를 방지하므로 유용하다.

### 다중 객체 트랜잭션 필요성

많은 분산 데이터스토어는 다중 객체 트랜잭션 지원을 포기했다. 왜냐하면 여러 파티션에 걸쳐 구현하기 어렵고 매우 높은 가용성과 성능이 필요한 곳에서는 방해가 되는 시나리오도 있기 때문이다.

### 오류와 어보트 처리

트랜잭션의 핵심은 어보트되고 안전하게 재시도가 가능한 것.

여기서 오류 복구는 애플리케이션에게 책임이 있다. 어보트된 트랜잭션을 재시도하는 것은 간단하고 효율적인 오류 처리 메커니즘이지만 완벽하진 않다.

- 트랜잭션이 성공했지만, 커밋 성공을 알리기 전 네트워크가 끊기고, 애플리케이션은 모르고 재시도하는 경우(중복 제거 메커니즘이 없다면)
- 오류가 과부하 때문이라면 재시도는 문제를 악화시킬 수 있다.(재시도 횟수 제한 고려)
- 일시적 오류만 재시도 가치가 있음(영구 오류라면 의미 없음)
- 트랜잭션이 데이터베이스 외부에 부수 효과가 있는 경우 (이메일은 이미 전송됐는데, 트랜잭션을 재시도했다고, 이메일이 또 재전송되길 바라지 않음)
- 클라이언트 프로세스가 재시도 중 죽어버리면 쓰기 데이터가 모두 손실된다.

## 완화된 격리 수준

- 두 트랜잭션이 서로 의존하지 않으면 안전하게 병렬 실행이 가능하다.
- 동시성 문제는 동일한 데이터에 대해 동시에 쓰려고 할 경우에만 나타난다.

## 커밋 후 읽기(read committed)

- 데이터베이스에서 읽을 때 커밋된 데이터만 보게 된다(더티 읽기 X)
- 데이터베이스에 쓸 때 커밋된 데이터만 덮어쓰게 된다(더티 쓰기 X)

### 더티 읽기 방지

![](/img/part2/7.1.png)

아직 커밋되지 않은 쓰기 데이터를 읽는 것.

커밋 후 읽기 격리 레벨에서는 더티 리드를 막아야 한다. 더티 리드를 막았을 때 유용한 이유

- 다른 트랜잭션이 잘못된 값으로 인해 잘못된 결정을 하지 않게 한다.
- 트랜잭션이 롤백되면, 다른 트랜잭션은 결코 커밋되지 않을 데이터를 볼 수 있게 된다.

### 더티 쓰기 방지

두 트랜잭션이 동일한 객체를 동시에 쓰려고 하면 나중에 쓴 내용이 먼저 쓴 내용을 덮어쓰게 된다.

- 이를 더티 쓰기(dirty write)라고 함.

더티 쓰기를 막음으로써 해당 문제를 해결한다.

![](/img/part2/7.2.png)

1. 트랜잭션들이 여러 객체를 갱신하면 더티 쓰기는 나쁜 결과를 유발할 수 있음.
2. 커밋후 읽기는 동시성 문제에서 경쟁 조건을 막지는 못한다.

### 커밋 후 읽기 구현

매우 널리 쓰이는 격리 수준이며, 가장 흔하게 로우 수준 잠금을 사용해 더티 쓰기를 방지할 수 있다.

트랜잭션에서는 쓰기를 하기 전에 해당 로우에 대한 잠금을 획득하고, 트랜잭션이 커밋/어보트 될 때까지 잠금을 보유하고 있어야 한다.

더티 읽기도 동일하게 잠금을 사용해 구현할 수 있지만, 읽기만 실행하는 여러 트랜잭션들이 쓰기 트랜잭션이 완료되길 기다려야 할 수 있기 때문에 현실적으로 잘 사용되진 않는다.

## 스냅숏 격리와 반복 읽기

커밋 후 읽기를 사용하더라도 동시성 버그가 생기는 경우는 존재한다.

![](/img/part2/7.3.png)

비반복 읽기(nonrepeatable read)나 읽기 스큐(read skew)가 있다.

스냅숏 격리는 이 문제의 가장 흔한 해결책이다. 각 트랜잭션은 일관된 트랜잭션으로 부터 읽는다.

- 중간에 데이터가 다른 트랜잭션에 의해 변경되더라도, 트랜잭션은 특정한 시점의 과거 데이터를 본다.

스냅숏 격리는 백업이나 분석처럼 오래 걸리며 읽기만 실행하는 질의에 요긴할 수 있다.

- 데이터가 중간에 변경된다면 혼란스럽기 때문

Postgresql, innoDB 저장소 엔진을 쓰는 mysql, oracle, sql 서버 등에서 지원됨.

### 스냅숏 격리 구현

더티 쓰기를 방지하기 위해 쓰기 잠금을 사용하며, 읽기 작업에 대한 차단을 하지 않는다.

데이터베이스는 커밋된 버전 여러개를 유지할 수 있기 때문에 **다중 버전 동시성 제어(MVCC)**라고도 한다.

![](/img/part2/7.4.png)

해당 로우를 삽입/삭제 요청을 한 트랜잭션 ID를 저장하며, 삭제 요청 로우에 대해서 접근하지 않음이 확실해지면 데이터베이스 가비지 컬렉션 프로세스가 해당 로우들을 실제 삭제한다.

### 일관된 스냅숏을 보는 가시성 규칙

트랜잭션은 데이터베이스에서 객체를 읽을 때 트랜잭션 ID를 사용해 판단한다.

- 읽기를 실행하는 트랜잭션이 시작한 시점에 읽기 대상 객체를 생성한 트랜잭션이 이미 커밋된 상태이다.
- 읽기 대상 객체가 삭제된 것으로 표시되지 않았다. 또는 삭제된 것으로 표시됐지만 읽기 실행한 트랜잭션이 시작한 시점에 삭제 요청 트랜잭션이 아직 커밋되지 않았다.

### 색인과 스냅숏 격리

다중 버전 데이터베이스에서 색인은 단순하게 객체의 모든 버전을 가리키고, 색인 질의가 현재 트랜잭션에서 볼 수 없는 버전을 걸러내게 하는 것이다.

### 반복 읽기와 혼란스러운 이름

오라클은 직렬성, 포스트그레스큐엘, mysql은 반복 읽기(repeatable read)라고 하는데, 초창기엔 스냅숏 격리 개념이 없었기 때문이다.

## 갱신 손실 방지

동시에 데이터베이스 쓰기를 할 경우 발생할 수 있는 또 다른 문제는 **갱신 손실(lost update)**이며 동시에 쓸 경우 먼저 쓴 데이터가 손실될 수 있다. (LWW)

갱신 손실 방지의 해결책

### 원자적 쓰기 연산

**커서 안정성(cursor stability)**라고도 부르는데, 갱신이 적용될 때 다른 트랜잭션에서 그 객체를 읽기 못하게 데이터베이스에서 원자적 연산을 제공해주는 것이다.

### 명시적인 잠금

애플리케이션에서 명시적으로 갱신할 객체를 잠그는 것.

- ex, for update

![](/img/part2/7.5.png)

### 갱신 손실 자동 감지

read-modify-write 주기가 순차적으로 실행되도록 해서 갱신 손실을 방지하는 것이다.

대안으로 병렬 실행을 허용하고, 트랜잭션 관리자가 갱신 손실을 발견하면 어보트 시키고 재시도하게끔 하는 방법.

- 어떠한 신경도 안 써도 자동으로 되기 때문에 매우 좋은 기능임.

mysql/innoDB는 갱신 손실 감지를 하지 않는다.

### Compare-and-set

![](/img/part2/7.6.png)

값을 마지막으로 읽은 후 해당 객체에 변경이 이루어졌는지 확인하고, 변경이 없었다면 갱신되게 한다. (갱신 손실 회피)

### 충돌 해소와 복제

복제 데이터베이스 환경에서는 최신 복사본이 여러개 존재할 수 있기 때문에

잠금과 compare-and-set 기법은 사용할 수 없다(최신 복사본이 하나라고 가정하기 때문에)

반면에 원자적 연산은 복제 상황에서도 잘 동작하고, 최종 쓰기 승리(LWW)는 갱신 손실이 발생하기 쉽지만, 많은 복제 데이터베이스는 LWW가 기본 설정이다.